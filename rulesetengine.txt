// src/main/java/com/example/ruleengine/RuleEngineApplication.java
package com.example.ruleengine;

import com.example.ruleengine.config.RuleFileConfig;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;

@SpringBootApplication
@EnableConfigurationProperties(RuleFileConfig.class) // Enable loading properties from application.properties/yml
public class RuleEngineApplication {

    public static void main(String[] args) {
        SpringApplication.run(RuleEngineApplication.class, args);
    }
}
```java
// src/main/java/com/example/ruleengine/config/RuleFileConfig.java
package com.example.ruleengine.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * Configuration properties for defining a single folder path where all rule files are located.
 * Loaded from application.properties or application.yml.
 * Converted to a Java Record for conciseness and immutability.
 *
 * This record maps directly to properties prefixed with 'rule.engine' in your configuration files.
 * Example: 'rule.engine.rules-folder-path=classpath:/rules/'
 */
@ConfigurationProperties(prefix = "rule.engine")
public record RuleFileConfig(
        String rulesFolderPath // Single folder path containing all rule files (e.g., "classpath:/rules/")
) {
    // Canonical constructor is implicit for records.
    // If 'rulesFolderPath' is not configured, it will be null, which is handled in RuleLoaderConfig.
}
```java
// src/main/java/com/example/ruleengine/model/Action.java
package com.example.ruleengine.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

/**
 * Represents an action to be performed if a rule's conditions are met.
 * This class is kept for model completeness but actions are no longer processed.
 * Converted to a Java Record for conciseness and immutability.
 */
@JacksonXmlRootElement(localName = "action")
public record Action(
        @JsonProperty("type") @JacksonXmlProperty(localName = "type") String type,
        @JsonProperty("value") @JacksonXmlProperty(localName = "value") String value) {
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/model/ConditionComponent.java
package com.example.ruleengine.model;

/**
 * Marker interface for components that can be part of a rule's condition logic.
 * This allows for polymorphic handling of individual conditions and condition groups.
 */
public interface ConditionComponent {}
```java
// src/main/java/com/example/ruleengine/model/Condition.java
package com.example.ruleengine.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

/**
 * Represents a single condition for a rule.
 * The 'expression' is a full SpEL boolean expression.
 * Converted to a Java Record for conciseness and immutability.
 */
@JacksonXmlRootElement(localName = "condition")
public record Condition(
        @JsonProperty("expression") @JacksonXmlProperty(localName = "expression") String expression)
        implements ConditionComponent { // Implements the marker interface
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/model/ConditionGroup.java
package com.example.ruleengine.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

import java.util.Collections;
import java.util.List;

/**
 * Represents a group of conditions that are combined using a logical operator (AND/OR).
 * This class can contain other ConditionComponents, enabling nested logic.
 * Converted to a Java Record for conciseness and immutability.
 */
@JacksonXmlRootElement(localName = "conditionGroup")
// These annotations are crucial for polymorphic deserialization with Jackson
@JsonTypeInfo(
    use = JsonTypeInfo.Id.NAME, // Use the type name as a property/wrapper
    include = JsonTypeInfo.As.WRAPPER_OBJECT // Wrap the object with the type name (e.g., {"condition": {...}} or <conditionGroup>...</conditionGroup>)
)
@JsonSubTypes({
    @JsonSubTypes.Type(value = Condition.class, name = "condition"), // Maps "condition" to Condition.class
    @JsonSubTypes.Type(value = ConditionGroup.class, name = "conditionGroup") // Maps "conditionGroup" to ConditionGroup.class
})
public record ConditionGroup(
        @JsonProperty("logicalOperator") @JacksonXmlProperty(localName = "logicalOperator") String logicalOperator,
        @JsonProperty("components") @JacksonXmlElementWrapper(localName = "components") @JacksonXmlProperty(localName = "component") List<ConditionComponent> components)
        implements ConditionComponent { // Implements the marker interface

    // Canonical constructor to ensure immutability of the components list
    public ConditionGroup {
        // Defensively copy the list to ensure immutability
        if (components != null) {
            components = Collections.unmodifiableList(components);
        }
    }
}
```java
// src/main/java/com/example/ruleengine/model/Rule.java
package com.example.ruleengine.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

/**
 * Represents a single rule with an ID, name, and a root condition group.
 * The 'paymentType' field has been removed from here as it's now at the RuleSet level.
 * Converted to a Java Record for conciseness and immutability.
 */
@JacksonXmlRootElement(localName = "rule")
public record Rule(
        @JsonProperty("id") @JacksonXmlProperty(localName = "id") String id,
        @JsonProperty("name") @JacksonXmlProperty(localName = "name") String name,
        @JsonProperty("rootConditionGroup") @JacksonXmlProperty(localName = "rootConditionGroup") ConditionGroup rootConditionGroup) {
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/model/RuleSet.java
package com.example.ruleengine.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;
import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;

import java.util.Collections;
import java.util.List;

/**
 * A wrapper class to hold a collection of rules, primarily for XML/JSON deserialization.
 * Now includes a 'paymentType' field to categorize the entire ruleset and a 'conditionExpression'
 * for more complex ruleset selection.
 * Converted to a Record for conciseness and immutability.
 */
@JacksonXmlRootElement(localName = "ruleSet")
public record RuleSet(
        @JsonProperty("paymentType") @JacksonXmlProperty(localName = "paymentType") String paymentType, // Added paymentType for the ruleset
        @JsonProperty("conditionExpression") @JacksonXmlProperty(localName = "conditionExpression") String conditionExpression, // Added conditionExpression for the ruleset
        @JsonProperty("rules") @JacksonXmlElementWrapper(localName = "rules") @JacksonXmlProperty(localName = "rule") List<Rule> rules) {

    // Canonical constructor to ensure immutability of the rules list
    public RuleSet {
        // Defensively copy the list to ensure immutability
        if (rules != null) {
            rules = Collections.unmodifiableList(rules);
        }
    }
}
```java
// src/main/java/com/example/ruleengine/model/RuleSetMetadata.java
package com.example.ruleengine.model;

import java.util.List;

/**
 * A record to hold metadata about a loaded ruleset, including its rules, associated payment type,
 * and a condition expression for ruleset selection.
 * This is used internally by the RuleEngineService to manage and filter rulesets.
 */
public record RuleSetMetadata(
        String name, // Added name for logging and identification
        List<Rule> rules,
        String paymentType, // Payment type associated with this entire ruleset
        String conditionExpression // Condition expression for this entire ruleset
) {
}
```java
// src/main/java/com/example/ruleengine/service/Address.java
package com.example.ruleengine.service;

/**
 * Nested DTO: Represents an address.
 * Converted to a Java Record for conciseness and immutability.
 */
public record Address(String street, String city, String zipCode) {
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/service/Customer.java
package com.example.ruleengine.service;

/**
 * Nested DTO: Represents a customer, containing an Address.
 * Converted to a Java Record for conciseness and immutability.
 */
public record Customer(String customerType, boolean isNewCustomer, Address address) {
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/service/InputData.java
package com.example.ruleengine.service;

/**
 * A POJO representing input data that rules will be applied to.
 * Now includes a paymentType field.
 * Converted to a Java Record for conciseness and immutability.
 */
public record InputData(Customer customer, double orderTotal, String paymentType) { // Added paymentType
    // No explicit constructor, getters, or toString needed as they are generated by the record.
}
```java
// src/main/java/com/example/ruleengine/service/RuleEngineService.java
package com.example.ruleengine.service;

import com.example.ruleengine.model.Condition;
import com.example.ruleengine.model.ConditionComponent;
import com.example.ruleengine.model.ConditionGroup;
import com.example.ruleengine.model.Rule;
import com.example.ruleengine.model.RuleSetMetadata; // Import the new metadata record
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * The core rule engine service responsible for loading rules and processing input data.
 * This version processes conditions organized into groups with AND/OR logic and returns a boolean result.
 * It now dynamically selects a ruleset based on input paymentType and a ruleset-level condition expression.
 * Optimized with proper logging and streamlined logic using Java 21 record patterns.
 */
@Service
public class RuleEngineService {

    private static final Logger logger = LoggerFactory.getLogger(RuleEngineService.class);

    // Map to hold all loaded rule sets metadata, keyed by their logical name (e.g., filename without extension)
    private final Map<String, RuleSetMetadata> loadedRuleSetsMetadata;

    // SpEL parser for evaluating conditions with nested fields and logical operators
    private final ExpressionParser parser = new SpelExpressionParser();

    /**
     * Constructor for RuleEngineService. Spring will inject the map of loaded rule set metadata.
     *
     * @param loadedRuleSetsMetadata A map where keys are rule set names and values are RuleSetMetadata objects.
     */
    public RuleEngineService(Map<String, RuleSetMetadata> loadedRuleSetsMetadata) {
        this.loadedRuleSetsMetadata = Collections.unmodifiableMap(loadedRuleSetsMetadata); // Ensure the map itself is immutable
        logger.info("RuleEngineService initialized with {} rule sets.", this.loadedRuleSetsMetadata.size());
        this.loadedRuleSetsMetadata.forEach((name, metadata) ->
            logger.debug("  - Rule Set '{}' loaded with {} rules (paymentType: {}, condition: {}).",
                    name, metadata.rules().size(), metadata.paymentType(), metadata.conditionExpression()));
    }

    /**
     * Processes the given input data by dynamically selecting the most applicable ruleset.
     * The selection is based on matching `paymentType` and evaluating the ruleset's `conditionExpression`.
     * The first ruleset found that matches both criteria will be processed.
     *
     * @param inputData The data to evaluate against the rules.
     * @return true if a matching ruleset was found and at least one rule within it matched, false otherwise.
     */
    public boolean process(InputData inputData) {
        logger.info("Attempting to process input data with paymentType '{}': {}", inputData.paymentType(), inputData);

        Optional<RuleSetMetadata> selectedRuleset = loadedRuleSetsMetadata.values().stream()
                .filter(rulesetMetadata -> {
                    // 1. Check paymentType match
                    boolean paymentTypeMatches = rulesetMetadata.paymentType() == null || rulesetMetadata.paymentType().isBlank()
                            || inputData.paymentType() == null || inputData.paymentType().isBlank()
                            || rulesetMetadata.paymentType().equalsIgnoreCase(inputData.paymentType());

                    if (!paymentTypeMatches) {
                        logger.debug("  Skipping ruleset '{}' due to paymentType mismatch. Ruleset PaymentType: '{}', Input PaymentType: '{}'",
                                rulesetMetadata.name(), rulesetMetadata.paymentType(), inputData.paymentType());
                        return false;
                    }

                    // 2. Evaluate ruleset-level condition expression (if present)
                    if (rulesetMetadata.conditionExpression() != null && !rulesetMetadata.conditionExpression().isBlank()) {
                        StandardEvaluationContext context = new StandardEvaluationContext(inputData);
                        boolean conditionMet = evaluateSpelExpression(rulesetMetadata.conditionExpression(), context);
                        if (!conditionMet) {
                            logger.debug("  Skipping ruleset '{}' due to condition expression not met: '{}'",
                                    rulesetMetadata.name(), rulesetMetadata.conditionExpression());
                            return false;
                        }
                    }
                    return true; // Both paymentType (if applicable) and conditionExpression (if applicable) matched
                })
                .findFirst(); // Take the first matching ruleset

        if (selectedRuleset.isEmpty()) {
            logger.info("No applicable ruleset found for input paymentType '{}' and data: {}. Returning false.", inputData.paymentType(), inputData);
            return false;
        }

        RuleSetMetadata rulesetToProcess = selectedRuleset.get();
        List<Rule> applicableRules = rulesetToProcess.rules();

        if (applicableRules.isEmpty()) {
            logger.warn("Selected ruleset '{}' is empty. Returning false.", rulesetToProcess.name());
            return false;
        }

        logger.info("Selected ruleset '{}' (paymentType: {}, condition: {}) for processing. Evaluating {} rules.",
                rulesetToProcess.name(), rulesetToProcess.paymentType(), rulesetToProcess.conditionExpression(), applicableRules.size());

        // Create a SpEL evaluation context with the input data as the root object
        StandardEvaluationContext context = new StandardEvaluationContext(inputData);

        for (Rule rule : applicableRules) {
            logger.debug("  Evaluating rule: {}", rule.name());
            if (rule.rootConditionGroup() == null) {
                logger.warn("    Rule '{}' has no root condition group defined. Skipping.", rule.name());
                continue; // Skip this rule if its condition group is missing
            }

            boolean ruleMatched = evaluateConditionComponent(rule.rootConditionGroup(), context);

            if (ruleMatched) {
                logger.info("  Rule '{}' conditions met in ruleset '{}'. Returning true.", rule.name(), rulesetToProcess.name());
                return true; // Return true as soon as the first rule matches
            } else {
                logger.debug("  Rule '{}' conditions not met in ruleset '{}'.", rule.name(), rulesetToProcess.name());
            }
        }
        logger.info("Processing complete for ruleset '{}'. No rules matched. Returning false.", rulesetToProcess.name());
        return false; // No rule matched after checking all applicable rules
    }

    /**
     * Recursively evaluates a ConditionComponent (either a Condition or a ConditionGroup).
     * This method traverses the condition tree, evaluating expressions and combining results
     * based on logical operators.
     * Uses Java 21 record patterns for concise type checking and component extraction.
     *
     * @param component The ConditionComponent to evaluate.
     * @param context The SpEL evaluation context with the input data as root.
     * @return true if the component evaluates to true, false otherwise.
     */
    private boolean evaluateConditionComponent(ConditionComponent component, StandardEvaluationContext context) {
        if (component instanceof Condition(String expression)) { // Java 21 record pattern
            boolean result = evaluateSpelExpression(expression, context);
            logger.debug("    Evaluating leaf condition: '{}' -> {}", expression, result);
            return result;
        } else if (component instanceof ConditionGroup(String logicalOperator, List<ConditionComponent> components)) { // Java 21 record pattern
            logger.debug("    Evaluating condition group with operator: {}", logicalOperator);

            if (components == null || components.isEmpty()) {
                logger.warn("      Warning: Condition group with operator '{}' is empty. Treating as false.", logicalOperator);
                return false; // An empty group should generally not match unless explicitly designed to.
            }

            boolean groupResult;
            if ("AND".equalsIgnoreCase(logicalOperator)) {
                groupResult = true; // Start with true for AND, all must be true
                for (ConditionComponent subComponent : components) {
                    if (!evaluateConditionComponent(subComponent, context)) {
                        groupResult = false;
                        break; // Short-circuit AND: if any component is false, the group is false
                    }
                }
            } else if ("OR".equalsIgnoreCase(logicalOperator)) {
                groupResult = false; // Start with false for OR, any true makes the group true
                for (ConditionComponent subComponent : components) {
                    if (evaluateConditionComponent(subComponent, context)) {
                        groupResult = true;
                        break; // Short-circuit OR: if any component is true, the group is true
                    }
                }
            } else {
                logger.error("      Unsupported logical operator for group: '{}'. Treating as false.", logicalOperator);
                return false; // Invalid operator
            }
            logger.debug("    Condition group result: {} -> {}", logicalOperator, groupResult);
            return groupResult;
        } else {
            logger.error("Unsupported condition component type: {}. Treating as false.", component.getClass().getName());
            return false; // Unknown component type
        }
    }

    /**
     * Helper method to evaluate a single SpEL boolean expression.
     *
     * @param expressionString The SpEL expression to evaluate.
     * @param context The SpEL evaluation context.
     * @return true if the expression evaluates to true, false otherwise.
     */
    private boolean evaluateSpelExpression(String expressionString, StandardEvaluationContext context) {
        try {
            // Evaluate the SpEL expression directly as a boolean
            Boolean result = parser.parseExpression(expressionString).getValue(context, Boolean.class);
            return result != null && result; // Ensure result is not null and is true
        } catch (Exception e) {
            logger.error("      Error evaluating SpEL expression '{}': {}", expressionString, e.getMessage(), e);
            return false;
        }
    }
}
```java
// src/main/java/com/example/ruleengine/loader/RuleLoader.java
package com.example.ruleengine.loader;

import com.example.ruleengine.model.RuleSet; // Changed return type to RuleSet
import java.io.IOException;

/**
 * Interface for loading rules from a source.
 * This defines the "wrapper" contract for different file types.
 * Now returns a complete RuleSet object, including its metadata.
 */
public interface RuleLoader {
    RuleSet loadRules() throws IOException; // Changed return type to RuleSet
}
```java
// src/main/java/com/example/ruleengine/loader/JsonRuleLoader.java
package com.example.ruleengine.loader;

import com.example.ruleengine.model.RuleSet; // Import RuleSet
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;

/**
 * RuleLoader implementation for JSON files.
 * Uses Jackson ObjectMapper to deserialize JSON into a RuleSet object.
 * Optimized with proper logging.
 */
public class JsonRuleLoader implements RuleLoader {

    private static final Logger logger = LoggerFactory.getLogger(JsonRuleLoader.class);

    private final ObjectMapper objectMapper;
    private final ResourceLoader resourceLoader;
    private final String filePath; // Path to a single JSON file

    public JsonRuleLoader(ObjectMapper objectMapper, ResourceLoader resourceLoader, String filePath) {
        this.objectMapper = objectMapper;
        this.resourceLoader = resourceLoader;
        this.filePath = filePath;
    }

    @Override
    public RuleSet loadRules() throws IOException { // Changed return type to RuleSet
        logger.info("Attempting to load rules from JSON file: {}", filePath);
        Resource resource = resourceLoader.getResource(filePath);
        if (!resource.exists()) {
            logger.warn("JSON rule file not found: {}", filePath);
            // Return an empty RuleSet if the file doesn't exist
            return new RuleSet(null, null, Collections.emptyList());
        }
        try (InputStream inputStream = resource.getInputStream()) {
            RuleSet ruleSet = objectMapper.readValue(inputStream, RuleSet.class);
            // Ensure the rules list within the loaded RuleSet is immutable
            return new RuleSet(ruleSet.paymentType(), ruleSet.conditionExpression(), Collections.unmodifiableList(ruleSet.rules()));
        } catch (IOException e) {
            logger.error("Error reading JSON rule file {}: {}", filePath, e.getMessage(), e);
            throw e; // Re-throw to be handled by RuleLoaderConfig
        }
    }
}
```java
// src/main/java/com/example/ruleengine/loader/XmlRuleLoader.java
package com.example.ruleengine.loader;

import com.example.ruleengine.model.RuleSet; // Import RuleSet
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.Resource;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;

/**
 * RuleLoader implementation for XML files.
 * Uses Jackson's XmlMapper to deserialize XML into a RuleSet object.
 * Optimized with proper logging.
 */
public class XmlRuleLoader implements RuleLoader {

    private static final Logger logger = LoggerFactory.getLogger(XmlRuleLoader.class);

    private final XmlMapper xmlMapper;
    private final ResourceLoader resourceLoader;
    private final String filePath; // Path to a single XML file

    public XmlRuleLoader(XmlMapper xmlMapper, ResourceLoader resourceLoader, String filePath) {
        this.xmlMapper = xmlMapper;
        this.resourceLoader = resourceLoader;
        this.filePath = filePath;
    }

    @Override
    public RuleSet loadRules() throws IOException { // Changed return type to RuleSet
        logger.info("Attempting to load rules from XML file: {}", filePath);
        Resource resource = resourceLoader.getResource(filePath);
        if (!resource.exists()) {
            logger.warn("XML rule file not found: {}", filePath);
            // Return an empty RuleSet if the file doesn't exist
            return new RuleSet(null, null, Collections.emptyList());
        }
        try (InputStream inputStream = resource.getInputStream()) {
            RuleSet ruleSet = xmlMapper.readValue(inputStream, RuleSet.class);
            // Ensure the rules list within the loaded RuleSet is immutable
            return new RuleSet(ruleSet.paymentType(), ruleSet.conditionExpression(), Collections.unmodifiableList(ruleSet.rules()));
        } catch (IOException e) {
            logger.error("Error reading XML rule file {}: {}", filePath, e.getMessage(), e);
            throw e; // Re-throw to be handled by RuleLoaderConfig
        }
    }
}
```java
// src/main/java/com/example/ruleengine/loader/TextRuleLoader.java
package com.example.ruleengine.loader;

import com.example.ruleengine.model.Condition;
import com.example.ruleengine.model.ConditionGroup;
import com.example.ruleengine.model.Rule;
import com.example.ruleengine.model.RuleSet; // Import RuleSet
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.util.FileCopyUtils;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.Arrays;

/**
 * RuleLoader implementation for plain text files.
 * This loader now expects the first non-empty, non-comment line to be the paymentType,
 * and the second non-empty, non-comment line to be the conditionExpression for the ruleset.
 * Subsequent lines are treated as individual SpEL rule expressions.
 * Optimized with proper logging.
 */
public class TextRuleLoader implements RuleLoader {

    private static final Logger logger = LoggerFactory.getLogger(TextRuleLoader.class);

    private final ResourceLoader resourceLoader;
    private final String filePath; // Path to a single text file
    private final AtomicInteger ruleCounter = new AtomicInteger(1); // For generating unique rule IDs and names

    public TextRuleLoader(ResourceLoader resourceLoader, String filePath) {
        this.resourceLoader = resourceLoader;
        this.filePath = filePath;
    }

    @Override
    public RuleSet loadRules() throws IOException { // Changed return type to RuleSet
        logger.info("Attempting to load rules from text file: {}", filePath);
        Resource resource = resourceLoader.getResource(filePath);
        if (!resource.exists()) {
            logger.warn("Text rule file not found: {}", filePath);
            return new RuleSet(null, null, Collections.emptyList()); // Return empty RuleSet
        }

        String paymentType = null;
        String conditionExpression = null;
        List<Rule> rules = new ArrayList<>();

        try (Reader reader = new InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8)) {
            String fileContent = FileCopyUtils.copyToString(reader);
            List<String> lines = Arrays.stream(fileContent.split("\\r?\\n"))
                                       .map(String::trim)
                                       .filter(line -> !line.isEmpty() && !line.startsWith("#")) // Filter empty lines and comments
                                       .collect(Collectors.toList());

            if (lines.size() >= 1) {
                paymentType = lines.get(0); // First non-empty, non-comment line is paymentType
                logger.debug("  Text file ruleset paymentType: {}", paymentType);
            }
            if (lines.size() >= 2) {
                conditionExpression = lines.get(1); // Second non-empty, non-comment line is conditionExpression
                logger.debug("  Text file ruleset conditionExpression: {}", conditionExpression);
            }

            // Process rules from the third line onwards
            for (int i = 2; i < lines.size(); i++) {
                String ruleLine = lines.get(i);
                try {
                    Condition condition = new Condition(ruleLine);
                    ConditionGroup rootGroup = new ConditionGroup("AND", List.of(condition));

                    String ruleId = "R-TEXT-" + String.format("%03d", ruleCounter.getAndIncrement());
                    String ruleName = "Text Rule " + ruleId + " - " + ruleLine;
                    rules.add(new Rule(ruleId, ruleName, rootGroup));
                } catch (Exception e) {
                    logger.error("Error processing rule line '{}' from file {}: {}", ruleLine, filePath, e.getMessage(), e);
                }
            }
        } catch (IOException e) {
            logger.error("Error reading text rule file {}: {}", filePath, e.getMessage(), e);
            throw e; // Re-throw to be handled by RuleLoaderConfig
        }
        logger.info("Finished loading rules from text file. Loaded {} rules.", rules.size());
        return new RuleSet(paymentType, conditionExpression, Collections.unmodifiableList(rules));
    }
}
```java
// src/main/java/com/example/ruleengine/loader/RuleLoaderConfig.java
package com.example.ruleengine.loader;

import com.example.ruleengine.config.RuleFileConfig;
import com.example.ruleengine.model.Rule;
import com.example.ruleengine.model.RuleSet; // Import RuleSet
import com.example.ruleengine.model.RuleSetMetadata; // Import the new metadata record
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.xml.XmlMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;

import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

/**
 * Spring configuration for providing the correct RuleLoader.
 * This configuration is responsible for:
 * 1. Defining ObjectMapper and XmlMapper beans for JSON and XML deserialization.
 * 2. Scanning a configured folder for rule files (JSON, XML, Text).
 * 3. Aggregating rules from all found files into a map of RuleSetMetadata, keyed by their filename (without extension).
 * 4. Providing this map of rule sets metadata as a bean to the application.
 *
 * It uses a centralized map of loader factories to avoid redundant conditional logic.
 */
@Configuration
public class RuleLoaderConfig {

    private static final Logger logger = LoggerFactory.getLogger(RuleLoaderConfig.class);

    private final RuleFileConfig ruleFileConfig;
    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;
    private final XmlMapper xmlMapper;
    private final ResourcePatternResolver resourcePatternResolver;
    // Map to hold functions (factories) that create specific RuleLoader instances based on file type.
    private final Map<String, Function<String, RuleLoader>> loaderFactories;

    /**
     * Constructor for RuleLoaderConfig. Spring will inject dependencies.
     *
     * @param ruleFileConfig Configuration properties for rule file paths.
     * @param resourceLoader Spring's ResourceLoader for accessing files.
     * @param objectMapper Jackson ObjectMapper for JSON deserialization.
     * @param xmlMapper Jackson XmlMapper for XML deserialization.
     */
    public RuleLoaderConfig(RuleFileConfig ruleFileConfig, ResourceLoader resourceLoader,
                            ObjectMapper objectMapper, XmlMapper xmlMapper) {
        this.ruleFileConfig = ruleFileConfig;
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
        this.xmlMapper = xmlMapper;
        // Initialize ResourcePatternResolver to scan for resources based on patterns.
        this.resourcePatternResolver = new PathMatchingResourcePatternResolver(resourceLoader);

        // Initialize the loader factories map.
        // Each entry maps a file extension (e.g., "json") to a function that, when given a file path,
        // returns a new instance of the corresponding RuleLoader.
        this.loaderFactories = Map.of(
            "json", filePath -> new JsonRuleLoader(this.objectMapper, this.resourceLoader, filePath),
            "xml", filePath -> new XmlRuleLoader(this.xmlMapper, this.resourceLoader, filePath),
            "txt", filePath -> new TextRuleLoader(this.resourceLoader, filePath) // Note: "txt" for text files
        );
    }

    /**
     * Provides a singleton ObjectMapper bean.
     *
     * @return An ObjectMapper instance.
     */
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }

    /**
     * Provides a singleton XmlMapper bean.
     *
     * @return An XmlMapper instance.
     */
    @Bean
    public XmlMapper xmlMapper() {
        return new XmlMapper();
    }

    /**
     * This bean scans the configured folder and aggregates rules from all
     * JSON, XML, and Text files found within it into a map of rule sets metadata.
     *
     * @return A Map where keys are rule set names (filenames without extension) and values are RuleSetMetadata objects.
     */
    @Bean
    public Map<String, RuleSetMetadata> loadedRuleSetsMetadata() {
        Map<String, RuleSetMetadata> ruleSetsMap = new HashMap<>();
        String rulesFolderPath = ruleFileConfig.rulesFolderPath(); // Get the configured folder path

        // Check if the folder path is configured
        if (rulesFolderPath == null || rulesFolderPath.isBlank()) {
            logger.warn("No rules folder path configured. Please check 'rule.engine.rules-folder-path' in application.properties.");
            return Collections.emptyMap();
        }

        // Construct the pattern to match all files directly within the specified folder (non-recursive)
        String folderPathPattern = rulesFolderPath;
        if (!folderPathPattern.endsWith("/")) {
            folderPathPattern += "/"; // Ensure the path ends with a slash for correct pattern matching
        }
        folderPathPattern += "*"; // Match all immediate children files, not recursively

        logger.info("Scanning rules folder: {}", folderPathPattern);
        try {
            // Get all resources (files) matching the pattern
            Resource[] resources = resourcePatternResolver.getResources(folderPathPattern);
            for (Resource resource : resources) {
                // Process only readable files with a valid filename
                if (resource.isReadable() && resource.getFilename() != null) {
                    String filename = resource.getFilename();
                    String fileExtension = getFileExtension(filename);
                    String filePath = resource.getURI().toString(); // Use URI for consistent path
                    String ruleSetName = getRuleSetName(filename); // Derive the rule set name

                    // Use the centralized loaderFactories map to get the correct loader factory
                    Function<String, RuleLoader> factory = loaderFactories.get(fileExtension.toLowerCase());

                    if (factory != null) {
                        try {
                            // Create the specific RuleLoader instance using its factory and load the RuleSet
                            RuleLoader ruleLoader = factory.apply(filePath);
                            RuleSet ruleSet = ruleLoader.loadRules(); // Now all loaders return RuleSet

                            // Create RuleSetMetadata from the loaded RuleSet and add to map
                            ruleSetsMap.put(ruleSetName, new RuleSetMetadata(
                                    ruleSetName, // Pass the name to metadata for easier logging/debugging
                                    ruleSet.rules(), // Rules list is already unmodifiable from loaders
                                    ruleSet.paymentType(),
                                    ruleSet.conditionExpression()
                            ));
                            logger.info("Loaded {} rules from file '{}' into rule set '{}' (paymentType: {}, condition: {}).",
                                    ruleSet.rules().size(), filename, ruleSetName,
                                    ruleSet.paymentType() != null ? ruleSet.paymentType() : "N/A",
                                    ruleSet.conditionExpression() != null ? ruleSet.conditionExpression() : "N/A");
                        } catch (IOException e) {
                            logger.error("Error loading rules from {} file: {}. {}", fileExtension, filePath, e.getMessage(), e);
                            // Continue processing other files even if one fails
                        }
                    } else {
                        logger.warn("Skipping unsupported file type: {} (File: {})", fileExtension, filename);
                    }
                }
            }
        } catch (IOException e) {
            logger.error("Error scanning rules folder {}: {}", rulesFolderPath, e.getMessage(), e);
        }

        logger.info("Successfully aggregated {} rule sets from folder '{}'.", ruleSetsMap.size(), rulesFolderPath);
        return Collections.unmodifiableMap(ruleSetsMap); // Ensure the map itself is immutable
    }

    /**
     * Extracts the file extension from a given filename.
     *
     * @param filename The name of the file.
     * @return The file extension (e.g., "json", "xml", "txt"), or an empty string if no extension is found.
     */
    private String getFileExtension(String filename) {
        int dotIndex = filename.lastIndexOf('.');
        return (dotIndex == -1) ? "" : filename.substring(dotIndex + 1);
    }

    /**
     * Derives a logical rule set name from the filename by removing the extension.
     *
     * @param filename The name of the file.
     * @return The rule set name.
     */
    private String getRuleSetName(String filename) {
        int dotIndex = filename.lastIndexOf('.');
        return (dotIndex == -1) ? filename : filename.substring(0, dotIndex);
    }
}
```java
// src/main/java/com/example/ruleengine/runner/RuleEngineCommandLineRunner.java
package com.example.ruleengine.runner;

import com.example.ruleengine.service.Address;
import com.example.ruleengine.service.Customer;
import com.example.ruleengine.service.InputData;
import com.example.ruleengine.service.RuleEngineService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

/**
 * CommandLineRunner to demonstrate the rule engine functionality on application startup.
 * It now demonstrates how the RuleEngineService dynamically selects a ruleset
 * based on input data, paymentType, and ruleset-level condition expressions.
 * Optimized with proper logging.
 */
@Component
public class RuleEngineCommandLineRunner implements CommandLineRunner {

    private static final Logger logger = LoggerFactory.getLogger(RuleEngineCommandLineRunner.class);

    private final RuleEngineService ruleEngineService;

    public RuleEngineCommandLineRunner(RuleEngineService ruleEngineService) {
        this.ruleEngineService = ruleEngineService;
    }

    @Override
    public void run(String... args) throws Exception {
        logger.info("--- Starting Rule Engine Demonstration ---");

        // --- Rulesets available and their properties ---
        // rules-discount:   paymentType="CreditCard", conditionExpression="inputData.orderTotal > 50.0"
        // rules-loyalty-fees: paymentType="Universal", conditionExpression="customer.customerType == 'Existing'"
        // rules-text:       paymentType="TextPayment", conditionExpression="inputData.customer.isNewCustomer == true"

        logger.info("--- Scenario 1: Input matches 'rules-discount' (CreditCard & orderTotal > 50) ---");
        // Expected: rules-discount ruleset selected, R001 matches
        InputData input1 = new InputData(new Customer("New", true, new Address("123 Main St", "New York", "10001")), 150.00, "CreditCard");
        boolean result1 = ruleEngineService.process(input1);
        logger.info("Scenario 1 Result: {}", (result1 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 2: Input does NOT match 'rules-discount' (paymentType mismatch) ---");
        // Expected: rules-discount ruleset skipped, no other ruleset matches this combination
        InputData input2 = new InputData(new Customer("New", true, new Address("123 Main St", "New York", "10001")), 150.00, "PayPal");
        boolean result2 = ruleEngineService.process(input2);
        logger.info("Scenario 2 Result: {}", (result2 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 3: Input does NOT match 'rules-discount' (conditionExpression not met) ---");
        // Expected: rules-discount ruleset skipped, no other ruleset matches this combination
        InputData input3 = new InputData(new Customer("New", true, new Address("123 Main St", "New York", "10001")), 30.00, "CreditCard"); // orderTotal <= 50.0
        boolean result3 = ruleEngineService.process(input3);
        logger.info("Scenario 3 Result: {}", (result3 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 4: Input matches 'rules-loyalty-fees' (Universal paymentType, Existing Customer) ---");
        // Expected: rules-loyalty-fees ruleset selected, R002 matches
        InputData input4 = new InputData(new Customer("Existing", false, new Address("456 Oak Ave", "Los Angeles", "90001")), 250.00, "AnyType");
        boolean result4 = ruleEngineService.process(input4);
        logger.info("Scenario 4 Result: {}", (result4 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 5: Input does NOT match 'rules-loyalty-fees' (conditionExpression not met - New Customer) ---");
        // Expected: rules-loyalty-fees ruleset skipped, no other ruleset matches
        InputData input5 = new InputData(new Customer("New", false, new Address("789 Pine Ln", "Chicago", "60601")), 60.00, "DebitCard");
        boolean result5 = ruleEngineService.process(input5);
        logger.info("Scenario 5 Result: {}", (result5 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 6: Input matches 'rules-text' (TextPayment, New Customer) ---");
        // Expected: rules-text ruleset selected, first rule matches
        InputData input6 = new InputData(new Customer("New", false, new Address("1 Text St", "Text City", "12345")), 250.0, "TextPayment");
        boolean result6 = ruleEngineService.process(input6);
        logger.info("Scenario 6 Result: {}", (result6 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 7: Input does NOT match 'rules-text' (conditionExpression not met - Existing Customer) ---");
        // Expected: rules-text ruleset skipped, no other ruleset matches
        InputData input7 = new InputData(new Customer("Existing", false, new Address("1 Text St", "Text City", "12345")), 250.0, "TextPayment");
        boolean result7 = ruleEngineService.process(input7);
        logger.info("Scenario 7 Result: {}", (result7 ? "A rule matched!" : "No rule matched."));

        logger.info("----------------------------------------");

        logger.info("--- Scenario 8: No ruleset matches (e.g., paymentType and condition don't align with any ruleset) ---");
        // Expected: No ruleset selected, no rule matches
        InputData input8 = new InputData(new Customer("Guest", false, new Address("999 Unknown St", "Nowhere", "00000")), 10.00, "Crypto");
        boolean result8 = ruleEngineService.process(input8);
        logger.info("Scenario 8 Result: {}", (result8 ? "A rule matched!" : "No rule matched."));


        logger.info("--- Rule Engine Demonstration Finished ---");
    }
}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ruleSet>
    <paymentType>CreditCard</paymentType>
    <conditionExpression>orderTotal > 50.0</conditionExpression> <rules>
        <rule>
            <id>R001</id>
            <name>New Customer Welcome Discount</name>
            <rootConditionGroup>
                <logicalOperator>AND</logicalOperator>
                <components>
                    <condition>
                        <expression>customer.isNewCustomer == true</expression>
                    </condition>
                    <condition>
                        <expression>orderTotal > 100.0</expression>
                    </condition>
                </components>
            </rootConditionGroup>
        </rule>
        <rule>
            <id>R004</id>
            <name>High Value Customer Discount</name>
            <rootConditionGroup>
                <logicalOperator>AND</logicalOperator>
                <components>
                    <condition>
                        <expression>orderTotal > 500.0</expression>
                    </condition>
                    <condition>
                        <expression>customer.customerType == 'Existing'</expression>
                    </condition>
                </components>
            </rootConditionGroup>
        </rule>
    </rules>
</ruleSet>
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ruleSet>
    <paymentType>Universal</paymentType>
    <conditionExpression>customer.customerType == 'Existing'</conditionExpression> <rules>
        <rule>
            <id>R002</id>
            <name>Loyalty Program Bonus (Nested OR)</name>
            <rootConditionGroup>
                <logicalOperator>AND</logicalOperator>
                <components>
                    <condition>
                        <expression>customer.customerType == 'Existing'</expression>
                    </condition>
                    <conditionGroup> <logicalOperator>OR</logicalOperator>
                        <components>
                            <condition>
                                <expression>orderTotal > 200.0</expression>
                            </condition>
                            <condition>
                                <expression>customer.isNewCustomer == true</expression>
                            </condition>
                        </components>
                    </conditionGroup>
                </components>
            </rootConditionGroup>
        </rule>
        <rule>
            <id>R003</id>
            <name>Small Order Processing Fee - General</name>
            <rootConditionGroup>
                <logicalOperator>AND</logicalOperator>
                <components>
                    <condition>
                        <expression>orderTotal &lt; 75.0</expression>
                    </condition>
                </components>
            </rootConditionGroup>
        </rule>
        <rule>
            <id>R005</id>
            <name>Small Order Processing Fee - Specific City OR Other City</name>
            <rootConditionGroup>
                <logicalOperator>AND</logicalOperator>
                <components>
                    <condition>
                        <expression>orderTotal &lt; 100.0</expression>
                    </condition>
                    <conditionGroup>
                        <logicalOperator>OR</logicalOperator>
                        <components>
                            <condition>
                                <expression>customer.address.city == 'Chicago'</expression>
                            </condition>
                            <condition>
                                <expression>customer.address.city == 'Springfield'</condition>
                            </condition>
                        </components>
                    </conditionGroup>
                </components>
            </rootConditionGroup>
        </rule>
    </rules>
</ruleSet>
```json
{
  "rules": [
    {
      "id": "R001",
      "name": "New Customer Welcome Discount",
      "rootConditionGroup": {
        "logicalOperator": "AND",
        "components": [
          {
            "condition": {
              "expression": "customer.isNewCustomer == true"
            }
          },
          {
            "condition": {
              "expression": "orderTotal > 100.0"
            }
          }
        ]
      }
    },
    {
      "id": "R004",
      "name": "High Value Customer Discount",
      "rootConditionGroup": {
        "logicalOperator": "AND",
        "components": [
          {
            "condition": {
              "expression": "orderTotal > 500.0"
            }
          },
          {
            "condition": {
              "expression": "customer.customerType == 'Existing'"
            }
          }
        ]
      }
    }
  ],
  "paymentType": "CreditCard",
  "conditionExpression": "orderTotal > 50.0"  // Added ruleset-level condition
}
```json
{
  "rules": [
    {
      "id": "R002",
      "name": "Loyalty Program Bonus (Nested OR)",
      "rootConditionGroup": {
        "logicalOperator": "AND",
        "components": [
          {
            "condition": {
              "expression": "customer.customerType == 'Existing'"
            "
            }
          },
          {
            "conditionGroup": {
              "logicalOperator": "OR",
              "components": [
                {
                  "condition": {
                    "expression": "orderTotal > 200.0"
                  }
                },
                {
                  "condition": {
                    "expression": "customer.isNewCustomer == true"
                  }
                }
              ]
            }
          }
        ]
      }
    },
    {
      "id": "R003",
      "name": "Small Order Processing Fee - General",
      "rootConditionGroup": {
        "logicalOperator": "AND",
        "components": [
          {
            "condition": {
              "expression": "orderTotal < 75.0"
            }
          }
        ]
      }
    },
    {
      "id": "R005",
      "name": "Small Order Processing Fee - Specific City OR Other City",
      "rootConditionGroup": {
        "logicalOperator": "AND",
        "components": [
          {
            "condition": {
              "expression": "orderTotal < 100.0"
            }
          },
          {
            "conditionGroup": {
              "logicalOperator": "OR",
              "components": [
                {
                  "condition": {
                    "expression": "customer.address.city == 'Chicago'"
                  }
                },
                {
                  "condition": {
                    "expression": "customer.address.city == 'Springfield'"
                  }
                }
              ]
            }
          }
        ]
      }
    }
  ],
  "paymentType": "Universal",
  "conditionExpression": "customer.customerType == 'Existing'"  // Added ruleset-level condition
}
```properties
# src/main/resources/application.properties

# Configure a single folder path where all rule files (JSON, XML, Text) are located.
# The RuleLoaderConfig will automatically scan this folder and load rules based on file extension.
# Example: If your rules are in src/main/resources/rules/, use classpath:/rules/
rule.engine.rules-folder-path=classpath:/rules/

# Configure logging to see DEBUG level messages from the rule engine
logging.level.com.example.ruleengine=DEBUG
```text
# src/main/resources/rules/rules-text.txt
# Rules for the text file loader.
# The first non-empty, non-comment line is the paymentType for this ruleset.
# The second non-empty, non-comment line is the conditionExpression for this ruleset.
# Subsequent lines are individual SpEL boolean expressions, each representing a rule.
# SpEL handles nested logical operators (AND/OR) and parentheses.

TextPayment
inputData.customer.isNewCustomer == true
(customer.customerType == 'Existing') and ((orderTotal > 200.0) or (customer.isNewCustomer == true))
orderTotal < 75.0
(orderTotal < 100.0) and ((customer.address.city == 'Chicago') or (customer.address.city == 'Springfield'))
customer.address.zipCode == '10001' and orderTotal > 10.0
customer.customerType == 'New' or customer.address.city == 'Dallas'
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="[http://maven.apache.org/POM/4.0.0](http://maven.apache.org/POM/4.0.0)" xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)"
         xsi:schemaLocation="[http://maven.apache.org/POM/4.0.0](http://maven.apache.org/POM/4.0.0) [https://maven.apache.org/xsd/maven-4.0.0.xsd](https://maven.apache.org/xsd/maven-4.0.0.xsd)">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/> </parent>
    <groupId>com.example</groupId>
    <artifactId>rule-engine</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>rule-engine</name>
    <description>Spring Boot Rule Engine with Configurable Rules</description>

    <properties>
        <java.version>21</java.version> </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>

        <dependency>
            <groupId>com.fasterxml.jackson.dataformat</groupId>
            <artifactId>jackson-dataformat-xml</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-expression</artifactId>
        </dependency>

        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-core</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>

</project>
